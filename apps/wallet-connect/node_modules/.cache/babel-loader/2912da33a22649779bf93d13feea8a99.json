{"ast":null,"code":"\"use strict\"; // See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\n\nimport { arrayify } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { Reader, Writer } from \"./coders/abstract-coder\";\nimport { AddressCoder } from \"./coders/address\";\nimport { ArrayCoder } from \"./coders/array\";\nimport { BooleanCoder } from \"./coders/boolean\";\nimport { BytesCoder } from \"./coders/bytes\";\nimport { FixedBytesCoder } from \"./coders/fixed-bytes\";\nimport { NullCoder } from \"./coders/null\";\nimport { NumberCoder } from \"./coders/number\";\nimport { StringCoder } from \"./coders/string\";\nimport { TupleCoder } from \"./coders/tuple\";\nimport { ParamType } from \"./fragments\";\nconst paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nconst paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\nexport class AbiCoder {\n  constructor(coerceFunc) {\n    logger.checkNew(new.target, AbiCoder);\n    defineReadOnly(this, \"coerceFunc\", coerceFunc || null);\n  }\n\n  _getCoder(param) {\n    switch (param.baseType) {\n      case \"address\":\n        return new AddressCoder(param.name);\n\n      case \"bool\":\n        return new BooleanCoder(param.name);\n\n      case \"string\":\n        return new StringCoder(param.name);\n\n      case \"bytes\":\n        return new BytesCoder(param.name);\n\n      case \"array\":\n        return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);\n\n      case \"tuple\":\n        return new TupleCoder((param.components || []).map(component => {\n          return this._getCoder(component);\n        }), param.name);\n\n      case \"\":\n        return new NullCoder(param.name);\n    } // u?int[0-9]*\n\n\n    let match = param.type.match(paramTypeNumber);\n\n    if (match) {\n      let size = parseInt(match[2] || \"256\");\n\n      if (size === 0 || size > 256 || size % 8 !== 0) {\n        logger.throwArgumentError(\"invalid \" + match[1] + \" bit length\", \"param\", param);\n      }\n\n      return new NumberCoder(size / 8, match[1] === \"int\", param.name);\n    } // bytes[0-9]+\n\n\n    match = param.type.match(paramTypeBytes);\n\n    if (match) {\n      let size = parseInt(match[1]);\n\n      if (size === 0 || size > 32) {\n        logger.throwArgumentError(\"invalid bytes length\", \"param\", param);\n      }\n\n      return new FixedBytesCoder(size, param.name);\n    }\n\n    return logger.throwArgumentError(\"invalid type\", \"type\", param.type);\n  }\n\n  _getWordSize() {\n    return 32;\n  }\n\n  _getReader(data, allowLoose) {\n    return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);\n  }\n\n  _getWriter() {\n    return new Writer(this._getWordSize());\n  }\n\n  getDefaultValue(types) {\n    const coders = types.map(type => this._getCoder(ParamType.from(type)));\n    const coder = new TupleCoder(coders, \"_\");\n    return coder.defaultValue();\n  }\n\n  encode(types, values) {\n    if (types.length !== values.length) {\n      logger.throwError(\"types/values length mismatch\", Logger.errors.INVALID_ARGUMENT, {\n        count: {\n          types: types.length,\n          values: values.length\n        },\n        value: {\n          types: types,\n          values: values\n        }\n      });\n    }\n\n    const coders = types.map(type => this._getCoder(ParamType.from(type)));\n    const coder = new TupleCoder(coders, \"_\");\n\n    const writer = this._getWriter();\n\n    coder.encode(writer, values);\n    return writer.data;\n  }\n\n  decode(types, data, loose) {\n    const coders = types.map(type => this._getCoder(ParamType.from(type)));\n    const coder = new TupleCoder(coders, \"_\");\n    return coder.decode(this._getReader(arrayify(data), loose));\n  }\n\n}\nexport const defaultAbiCoder = new AbiCoder();","map":{"version":3,"sources":["../src.ts/abi-coder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\nimport { arrayify } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { Reader, Writer } from \"./coders/abstract-coder\";\nimport { AddressCoder } from \"./coders/address\";\nimport { ArrayCoder } from \"./coders/array\";\nimport { BooleanCoder } from \"./coders/boolean\";\nimport { BytesCoder } from \"./coders/bytes\";\nimport { FixedBytesCoder } from \"./coders/fixed-bytes\";\nimport { NullCoder } from \"./coders/null\";\nimport { NumberCoder } from \"./coders/number\";\nimport { StringCoder } from \"./coders/string\";\nimport { TupleCoder } from \"./coders/tuple\";\nimport { ParamType } from \"./fragments\";\nconst paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nconst paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\nexport class AbiCoder {\n    constructor(coerceFunc) {\n        logger.checkNew(new.target, AbiCoder);\n        defineReadOnly(this, \"coerceFunc\", coerceFunc || null);\n    }\n    _getCoder(param) {\n        switch (param.baseType) {\n            case \"address\":\n                return new AddressCoder(param.name);\n            case \"bool\":\n                return new BooleanCoder(param.name);\n            case \"string\":\n                return new StringCoder(param.name);\n            case \"bytes\":\n                return new BytesCoder(param.name);\n            case \"array\":\n                return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);\n            case \"tuple\":\n                return new TupleCoder((param.components || []).map((component) => {\n                    return this._getCoder(component);\n                }), param.name);\n            case \"\":\n                return new NullCoder(param.name);\n        }\n        // u?int[0-9]*\n        let match = param.type.match(paramTypeNumber);\n        if (match) {\n            let size = parseInt(match[2] || \"256\");\n            if (size === 0 || size > 256 || (size % 8) !== 0) {\n                logger.throwArgumentError(\"invalid \" + match[1] + \" bit length\", \"param\", param);\n            }\n            return new NumberCoder(size / 8, (match[1] === \"int\"), param.name);\n        }\n        // bytes[0-9]+\n        match = param.type.match(paramTypeBytes);\n        if (match) {\n            let size = parseInt(match[1]);\n            if (size === 0 || size > 32) {\n                logger.throwArgumentError(\"invalid bytes length\", \"param\", param);\n            }\n            return new FixedBytesCoder(size, param.name);\n        }\n        return logger.throwArgumentError(\"invalid type\", \"type\", param.type);\n    }\n    _getWordSize() { return 32; }\n    _getReader(data, allowLoose) {\n        return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);\n    }\n    _getWriter() {\n        return new Writer(this._getWordSize());\n    }\n    getDefaultValue(types) {\n        const coders = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = new TupleCoder(coders, \"_\");\n        return coder.defaultValue();\n    }\n    encode(types, values) {\n        if (types.length !== values.length) {\n            logger.throwError(\"types/values length mismatch\", Logger.errors.INVALID_ARGUMENT, {\n                count: { types: types.length, values: values.length },\n                value: { types: types, values: values }\n            });\n        }\n        const coders = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = (new TupleCoder(coders, \"_\"));\n        const writer = this._getWriter();\n        coder.encode(writer, values);\n        return writer.data;\n    }\n    decode(types, data, loose) {\n        const coders = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = new TupleCoder(coders, \"_\");\n        return coder.decode(this._getReader(arrayify(data), loose));\n    }\n}\nexport const defaultAbiCoder = new AbiCoder();\n//# sourceMappingURL=abi-coder.js.map"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"/**\n * Convert a typed array to a Buffer without a copy\n *\n * Author:   Feross Aboukhadijeh <https://feross.org>\n * License:  MIT\n *\n * `npm install typedarray-to-buffer`\n */\nvar isTypedArray = require('is-typedarray').strict;\n\nmodule.exports = function typedarrayToBuffer(arr) {\n  if (isTypedArray(arr)) {\n    // To avoid a copy, use the typed array's underlying ArrayBuffer to back new Buffer\n    var buf = Buffer.from(arr.buffer);\n\n    if (arr.byteLength !== arr.buffer.byteLength) {\n      // Respect the \"view\", i.e. byteOffset and byteLength, without doing a copy\n      buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);\n    }\n\n    return buf;\n  } else {\n    // Pass through all other types to `Buffer.from`\n    return Buffer.from(arr);\n  }\n};","map":{"version":3,"sources":["/Users/mdastugu/Projects/safe-react-apps/node_modules/typedarray-to-buffer/index.js"],"names":["isTypedArray","require","strict","module","exports","typedarrayToBuffer","arr","buf","Buffer","from","buffer","byteLength","slice","byteOffset"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,IAAIA,YAAY,GAAGC,OAAO,CAAC,eAAD,CAAP,CAAyBC,MAA5C;;AAEAC,MAAM,CAACC,OAAP,GAAiB,SAASC,kBAAT,CAA6BC,GAA7B,EAAkC;AACjD,MAAIN,YAAY,CAACM,GAAD,CAAhB,EAAuB;AACrB;AACA,QAAIC,GAAG,GAAGC,MAAM,CAACC,IAAP,CAAYH,GAAG,CAACI,MAAhB,CAAV;;AACA,QAAIJ,GAAG,CAACK,UAAJ,KAAmBL,GAAG,CAACI,MAAJ,CAAWC,UAAlC,EAA8C;AAC5C;AACAJ,MAAAA,GAAG,GAAGA,GAAG,CAACK,KAAJ,CAAUN,GAAG,CAACO,UAAd,EAA0BP,GAAG,CAACO,UAAJ,GAAiBP,GAAG,CAACK,UAA/C,CAAN;AACD;;AACD,WAAOJ,GAAP;AACD,GARD,MAQO;AACL;AACA,WAAOC,MAAM,CAACC,IAAP,CAAYH,GAAZ,CAAP;AACD;AACF,CAbD","sourcesContent":["/**\n * Convert a typed array to a Buffer without a copy\n *\n * Author:   Feross Aboukhadijeh <https://feross.org>\n * License:  MIT\n *\n * `npm install typedarray-to-buffer`\n */\n\nvar isTypedArray = require('is-typedarray').strict\n\nmodule.exports = function typedarrayToBuffer (arr) {\n  if (isTypedArray(arr)) {\n    // To avoid a copy, use the typed array's underlying ArrayBuffer to back new Buffer\n    var buf = Buffer.from(arr.buffer)\n    if (arr.byteLength !== arr.buffer.byteLength) {\n      // Respect the \"view\", i.e. byteOffset and byteLength, without doing a copy\n      buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength)\n    }\n    return buf\n  } else {\n    // Pass through all other types to `Buffer.from`\n    return Buffer.from(arr)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}